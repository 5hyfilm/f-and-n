// src/hooks/inventory/useInventoryOperations.tsx - Fix: QuantityInput Support
"use client";

import { useCallback } from "react";
import { Product } from "../../types/product";
import {
  InventoryItem,
  EmployeeContext,
  QuantityInput,
  QuantityDetail,
  isQuantityDetail,
  isSimpleQuantity,
  migrateQuantityToDetail,
} from "./types";

interface UseInventoryOperationsProps {
  inventory: InventoryItem[];
  setInventory: React.Dispatch<React.SetStateAction<InventoryItem[]>>;
  saveInventory: (data: InventoryItem[]) => boolean;
  employeeContext?: EmployeeContext;
  setError: (error: string | null) => void;
}

export const useInventoryOperations = ({
  inventory,
  setInventory,
  saveInventory,
  employeeContext,
  setError,
}: UseInventoryOperationsProps) => {
  // Helper function to map category to product group (for existing products only)
  const mapCategoryToProductGroup = useCallback((category: string): string => {
    const categoryMapping: Record<string, string> = {
      beverages: "STM",
      dairy: "EVAP",
      confectionery: "Gummy",
      snacks: "SNACK",
      canned_food: "EVAP",
    };

    return categoryMapping[category.toLowerCase()] || "OTHER";
  }, []);

  // ‚úÖ Helper function to determine product group correctly
  const getProductGroupForItem = useCallback(
    (
      product: Product,
      directProductGroup?: string // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° parameter ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö product group ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡∏ï‡∏£‡∏á‡πÜ
    ): string => {
      // ‚úÖ ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ directProductGroup (‡∏à‡∏≤‡∏Å form) ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡∏£‡∏á‡πÜ
      if (directProductGroup) {
        console.log("üéØ Using direct product group:", directProductGroup);
        return directProductGroup;
      }

      // ‚úÖ ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ mapping ‡πÄ‡∏î‡∏¥‡∏° (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏à‡∏≤‡∏Å CSV)
      const mappedGroup = mapCategoryToProductGroup(product.category || "");
      console.log(
        "üîÑ Mapped product group from category:",
        product.category,
        "->",
        mappedGroup
      );
      return mappedGroup;
    },
    [mapCategoryToProductGroup]
  );

  // ‚úÖ Helper function to normalize quantity input
  const normalizeQuantityInput = useCallback(
    (
      quantityInput: QuantityInput,
      barcodeType?: "ea" | "dsp" | "cs"
    ): { quantity: number; quantityDetail?: QuantityDetail } => {
      if (isSimpleQuantity(quantityInput)) {
        // Handle old format (number)
        const effectiveBarcodeType = barcodeType || "ea";

        if (effectiveBarcodeType === "ea") {
          // For EA, keep simple quantity
          return {
            quantity: quantityInput,
          };
        } else {
          // For DSP/CS, create quantityDetail
          const quantityDetail = migrateQuantityToDetail(
            quantityInput,
            effectiveBarcodeType
          );
          return {
            quantity: quantityInput, // Keep for backward compatibility
            quantityDetail,
          };
        }
      }

      if (isQuantityDetail(quantityInput)) {
        // Handle new format (QuantityDetail)
        return {
          quantity: quantityInput.major, // Use major as primary quantity for compatibility
          quantityDetail: quantityInput,
        };
      }

      // Fallback
      setError("‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
      return { quantity: 1 };
    },
    [setError]
  );

  // ‚úÖ Validate quantity detail
  const validateQuantityDetail = useCallback(
    (detail: QuantityDetail): boolean => {
      if (detail.major < 0 || detail.remainder < 0) {
        setError("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏•‡∏ö");
        return false;
      }

      if (detail.major === 0 && detail.remainder === 0) {
        setError("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 0");
        return false;
      }

      // Additional validation based on scanned type
      if (detail.scannedType !== "ea" && detail.major === 0) {
        setError(`‡∏à‡∏≥‡∏ô‡∏ß‡∏ô ${detail.scannedType.toUpperCase()} ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 0`);
        return false;
      }

      return true;
    },
    [setError]
  );

  // ‚úÖ Enhanced add or update inventory item with QuantityInput support and direct productGroup
  const addOrUpdateItem = useCallback(
    (
      product: Product,
      quantityInput: QuantityInput, // ‚úÖ Changed from number to QuantityInput
      barcodeType?: "ea" | "dsp" | "cs",
      directProductGroup?: string // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° parameter ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö product group ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡∏ï‡∏£‡∏á‡πÜ
    ): boolean => {
      try {
        setError(null);

        console.log("üì¶ Adding/updating item:", {
          productName: product.name,
          category: product.category,
          directProductGroup,
          quantityInput,
          barcodeType,
        });

        // ‚úÖ Normalize quantity input to handle both formats
        const { quantity, quantityDetail } = normalizeQuantityInput(
          quantityInput,
          barcodeType
        );

        // ‚úÖ Validate quantity detail if present
        if (quantityDetail && !validateQuantityDetail(quantityDetail)) {
          return false;
        }

        const timestamp = new Date().toISOString();
        const itemId = `${product.barcode}_${
          barcodeType || "ea"
        }_${Date.now()}`;

        // Check if item already exists (by barcode and type)
        const existingItemIndex = inventory.findIndex(
          (item) =>
            item.barcode === product.barcode &&
            item.barcodeType === (barcodeType || "ea")
        );

        // ‚úÖ Use the helper function to get correct product group
        const productGroup = getProductGroupForItem(
          product,
          directProductGroup
        );

        const newItem: InventoryItem = {
          id: itemId,
          barcode: product.barcode || "",
          productName: product.name || "",
          brand: product.brand || "",
          category: product.category || "",
          size: product.size?.toString() || "",
          unit: product.unit || "",

          // ‚úÖ Maintain backward compatibility
          quantity,
          quantityDetail,

          lastUpdated: timestamp,
          productData: product,
          addedBy: employeeContext?.employeeName || "",
          branchCode: employeeContext?.branchCode || "",
          branchName: employeeContext?.branchName || "",
          barcodeType: barcodeType || "ea",
          materialCode: product.sku || "",
          productGroup: productGroup, // ‚úÖ ‡πÉ‡∏ä‡πâ helper function ‡πÅ‡∏ó‡∏ô direct mapping
          thaiDescription: product.description || "",
        };

        console.log(
          "‚úÖ Created inventory item with productGroup:",
          productGroup
        );

        let updatedInventory: InventoryItem[];

        if (existingItemIndex >= 0) {
          // ‚úÖ Update existing item - merge quantities appropriately
          const existingItem = inventory[existingItemIndex];

          if (quantityDetail && existingItem.quantityDetail) {
            // Both have quantityDetail - add them
            const mergedDetail: QuantityDetail = {
              major: existingItem.quantityDetail.major + quantityDetail.major,
              remainder:
                existingItem.quantityDetail.remainder +
                quantityDetail.remainder,
              scannedType: quantityDetail.scannedType, // Use new scanned type
            };

            newItem.quantity = mergedDetail.major;
            newItem.quantityDetail = mergedDetail;
          } else if (quantityDetail) {
            // New has detail, existing doesn't - use new format
            newItem.quantity = quantity;
            newItem.quantityDetail = quantityDetail;
          } else if (existingItem.quantityDetail) {
            // Existing has detail, new doesn't - convert and add
            const convertedDetail = migrateQuantityToDetail(
              quantity,
              barcodeType || "ea"
            );
            const mergedDetail: QuantityDetail = {
              major: existingItem.quantityDetail.major + convertedDetail.major,
              remainder:
                existingItem.quantityDetail.remainder +
                convertedDetail.remainder,
              scannedType: existingItem.quantityDetail.scannedType,
            };

            newItem.quantity = mergedDetail.major;
            newItem.quantityDetail = mergedDetail;
          } else {
            // Both simple quantities - add normally
            newItem.quantity = existingItem.quantity + quantity;
          }

          updatedInventory = [...inventory];
          updatedInventory[existingItemIndex] = newItem;
        } else {
          // Add new item
          updatedInventory = [...inventory, newItem];
        }

        setInventory(updatedInventory);
        const saved = saveInventory(updatedInventory);

        if (saved) {
          console.log("‚úÖ Successfully added/updated inventory item:", {
            product: product.name,
            quantity: quantity,
            quantityDetail: quantityDetail,
            barcodeType: barcodeType || "ea",
            productGroup: productGroup,
          });
          return true;
        } else {
          setError("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ");
          return false;
        }
      } catch (error) {
        console.error("‚ùå Error adding/updating inventory:", error);
        setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•");
        return false;
      }
    },
    [
      inventory,
      setInventory,
      saveInventory,
      employeeContext,
      setError,
      getProductGroupForItem, // ‚úÖ ‡πÉ‡∏ä‡πâ helper function ‡πÉ‡∏´‡∏°‡πà
      normalizeQuantityInput,
      validateQuantityDetail,
    ]
  );

  // Update item quantity (backward compatibility)
  const updateItemQuantity = useCallback(
    (itemId: string, newQuantity: number): boolean => {
      try {
        setError(null);

        if (newQuantity < 0) {
          setError("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏•‡∏ö");
          return false;
        }

        const updatedInventory = inventory.map((item) => {
          if (item.id === itemId) {
            const updatedItem = {
              ...item,
              quantity: newQuantity,
              lastUpdated: new Date().toISOString(),
            };

            // ‚úÖ If item has quantityDetail, update major but keep structure
            if (item.quantityDetail) {
              updatedItem.quantityDetail = {
                ...item.quantityDetail,
                major: newQuantity,
              };
            }

            return updatedItem;
          }
          return item;
        });

        setInventory(updatedInventory);
        return saveInventory(updatedInventory);
      } catch (error) {
        console.error("‚ùå Error updating quantity:", error);
        setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏à‡∏≥‡∏ô‡∏ß‡∏ô");
        return false;
      }
    },
    [inventory, setInventory, saveInventory, setError]
  );

  // ‚úÖ New method for updating quantity details
  const updateItemQuantityDetail = useCallback(
    (itemId: string, quantityDetail: QuantityDetail): boolean => {
      try {
        setError(null);

        if (!validateQuantityDetail(quantityDetail)) {
          return false;
        }

        const updatedInventory = inventory.map((item) => {
          if (item.id === itemId) {
            return {
              ...item,
              quantity: quantityDetail.major, // Update main quantity for compatibility
              quantityDetail,
              lastUpdated: new Date().toISOString(),
            };
          }
          return item;
        });

        setInventory(updatedInventory);
        return saveInventory(updatedInventory);
      } catch (error) {
        console.error("‚ùå Error updating quantity detail:", error);
        setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô");
        return false;
      }
    },
    [inventory, setInventory, saveInventory, setError, validateQuantityDetail]
  );

  // Remove item
  const removeItem = useCallback(
    (itemId: string): boolean => {
      try {
        setError(null);
        const updatedInventory = inventory.filter((item) => item.id !== itemId);
        setInventory(updatedInventory);
        return saveInventory(updatedInventory);
      } catch (error) {
        console.error("‚ùå Error removing item:", error);
        setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•");
        return false;
      }
    },
    [inventory, setInventory, saveInventory, setError]
  );

  // Clear all inventory
  const clearInventory = useCallback((): boolean => {
    try {
      setError(null);
      setInventory([]);
      return saveInventory([]);
    } catch (error) {
      console.error("‚ùå Error clearing inventory:", error);
      setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•");
      return false;
    }
  }, [setInventory, saveInventory, setError]);

  // Find item by barcode
  const findItemByBarcode = useCallback(
    (barcode: string): InventoryItem | undefined => {
      return inventory.find((item) => item.barcode === barcode);
    },
    [inventory]
  );

  // Search items
  const searchItems = useCallback(
    (searchTerm: string): InventoryItem[] => {
      if (!searchTerm.trim()) return inventory;

      const term = searchTerm.toLowerCase();
      return inventory.filter(
        (item) =>
          item.productName.toLowerCase().includes(term) ||
          item.brand.toLowerCase().includes(term) ||
          item.barcode.includes(term) ||
          item.category.toLowerCase().includes(term)
      );
    },
    [inventory]
  );

  return {
    addOrUpdateItem,
    updateItemQuantity,
    updateItemQuantityDetail, // ‚úÖ New method
    removeItem,
    clearInventory,
    findItemByBarcode,
    searchItems,
  };
};
