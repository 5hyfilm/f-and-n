// src/hooks/useInventoryManager.tsx
"use client";

import { useState, useCallback, useEffect } from "react";
import { Product } from "../types/product";

// Interface ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• inventory item
export interface InventoryItem {
  id: string;
  barcode: string;
  productName: string;
  brand: string;
  category: string;
  size: string;
  unit: string;
  quantity: number;
  lastUpdated: string;
  productData?: Product; // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÄ‡∏ï‡πá‡∏°
}

// Interface ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö summary ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
export interface InventorySummary {
  totalItems: number;
  totalProducts: number;
  lastUpdate: string;
  categories: Record<string, number>;
  brands: Record<string, number>;
}

const STORAGE_KEY = "fn_inventory_data";
const VERSION_KEY = "fn_inventory_version";
const CURRENT_VERSION = "1.0";

export const useInventoryManager = () => {
  const [inventory, setInventory] = useState<InventoryItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Load inventory data from localStorage
  const loadInventory = useCallback(() => {
    try {
      setIsLoading(true);
      setError(null);

      // Check version compatibility
      const savedVersion = localStorage.getItem(VERSION_KEY);
      if (savedVersion && savedVersion !== CURRENT_VERSION) {
        console.warn("üîÑ Inventory version mismatch, clearing old data");
        localStorage.removeItem(STORAGE_KEY);
        localStorage.setItem(VERSION_KEY, CURRENT_VERSION);
      }

      const savedData = localStorage.getItem(STORAGE_KEY);

      if (savedData) {
        const parsedData: InventoryItem[] = JSON.parse(savedData);

        // Validate data structure
        const validatedData = parsedData.filter(
          (item) =>
            item.id &&
            item.barcode &&
            item.productName &&
            typeof item.quantity === "number"
        );

        setInventory(validatedData);
        console.log("üì¶ Loaded inventory:", validatedData.length, "items");
      } else {
        setInventory([]);
        console.log("üì¶ No saved inventory found, starting fresh");
      }
    } catch (err: any) {
      console.error("‚ùå Error loading inventory:", err);
      setError("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• inventory ‡πÑ‡∏î‡πâ");
      setInventory([]);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Save inventory data to localStorage
  const saveInventory = useCallback((data: InventoryItem[]) => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      localStorage.setItem(VERSION_KEY, CURRENT_VERSION);
      console.log("üíæ Saved inventory:", data.length, "items");
    } catch (err: any) {
      console.error("‚ùå Error saving inventory:", err);
      setError("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ");
    }
  }, []);

  // Add or update inventory item
  const addOrUpdateItem = useCallback(
    (product: Product, quantity: number) => {
      if (!product || quantity <= 0) {
        setError("‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
        return false;
      }

      try {
        setError(null);

        const newItem: InventoryItem = {
          id: `${product.barcode}_${Date.now()}`,
          barcode: product.barcode,
          productName: product.name,
          brand: product.brand,
          category: product.category,
          size: product.size || "",
          unit: product.unit || "",
          quantity: quantity,
          lastUpdated: new Date().toISOString(),
          productData: product,
        };

        setInventory((prevInventory) => {
          // Check if product already exists (same barcode)
          const existingIndex = prevInventory.findIndex(
            (item) => item.barcode === product.barcode
          );

          let updatedInventory: InventoryItem[];

          if (existingIndex !== -1) {
            // Update existing item - add to current quantity
            updatedInventory = prevInventory.map((item, index) =>
              index === existingIndex
                ? {
                    ...item,
                    quantity: item.quantity + quantity,
                    lastUpdated: new Date().toISOString(),
                    productData: product, // Update product data
                  }
                : item
            );
            console.log(
              `üì¶ Updated existing item: ${product.name} (+${quantity})`
            );
          } else {
            // Add new item
            updatedInventory = [...prevInventory, newItem];
            console.log(`üì¶ Added new item: ${product.name} (${quantity})`);
          }

          saveInventory(updatedInventory);
          return updatedInventory;
        });

        return true;
      } catch (err: any) {
        console.error("‚ùå Error adding/updating item:", err);
        setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤");
        return false;
      }
    },
    [saveInventory]
  );

  // Update specific item quantity
  const updateItemQuantity = useCallback(
    (itemId: string, newQuantity: number) => {
      if (newQuantity < 0) {
        setError("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 0");
        return false;
      }

      try {
        setError(null);

        setInventory((prevInventory) => {
          const updatedInventory = prevInventory
            .map((item) =>
              item.id === itemId
                ? {
                    ...item,
                    quantity: newQuantity,
                    lastUpdated: new Date().toISOString(),
                  }
                : item
            )
            .filter((item) => item.quantity > 0); // Remove items with 0 quantity

          saveInventory(updatedInventory);
          return updatedInventory;
        });

        return true;
      } catch (err: any) {
        console.error("‚ùå Error updating item quantity:", err);
        setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏à‡∏≥‡∏ô‡∏ß‡∏ô");
        return false;
      }
    },
    [saveInventory]
  );

  // Remove specific item
  const removeItem = useCallback(
    (itemId: string) => {
      try {
        setError(null);

        setInventory((prevInventory) => {
          const updatedInventory = prevInventory.filter(
            (item) => item.id !== itemId
          );
          saveInventory(updatedInventory);
          console.log("üóëÔ∏è Removed item:", itemId);
          return updatedInventory;
        });

        return true;
      } catch (err: any) {
        console.error("‚ùå Error removing item:", err);
        setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤");
        return false;
      }
    },
    [saveInventory]
  );

  // Clear all inventory
  const clearInventory = useCallback(() => {
    try {
      setError(null);
      setInventory([]);
      localStorage.removeItem(STORAGE_KEY);
      console.log("üóëÔ∏è Cleared all inventory");
      return true;
    } catch (err: any) {
      console.error("‚ùå Error clearing inventory:", err);
      setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î");
      return false;
    }
  }, []);

  // Get inventory summary
  const getInventorySummary = useCallback((): InventorySummary => {
    const totalItems = inventory.reduce((sum, item) => sum + item.quantity, 0);
    const totalProducts = inventory.length;

    const categories: Record<string, number> = {};
    const brands: Record<string, number> = {};

    let lastUpdate = "";

    inventory.forEach((item) => {
      // Count by category
      categories[item.category] =
        (categories[item.category] || 0) + item.quantity;

      // Count by brand
      brands[item.brand] = (brands[item.brand] || 0) + item.quantity;

      // Track latest update
      if (item.lastUpdated > lastUpdate) {
        lastUpdate = item.lastUpdated;
      }
    });

    return {
      totalItems,
      totalProducts,
      lastUpdate,
      categories,
      brands,
    };
  }, [inventory]);

  // Find item by barcode
  const findItemByBarcode = useCallback(
    (barcode: string) => {
      return inventory.find((item) => item.barcode === barcode);
    },
    [inventory]
  );

  // Search items
  const searchItems = useCallback(
    (searchTerm: string) => {
      const term = searchTerm.toLowerCase();
      return inventory.filter(
        (item) =>
          item.productName.toLowerCase().includes(term) ||
          item.brand.toLowerCase().includes(term) ||
          item.barcode.includes(term) ||
          item.category.toLowerCase().includes(term)
      );
    },
    [inventory]
  );

  // Export inventory data
  const exportInventory = useCallback(() => {
    try {
      const summary = getInventorySummary();
      const exportData = {
        summary,
        items: inventory,
        exportDate: new Date().toISOString(),
        version: CURRENT_VERSION,
      };

      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: "application/json" });

      const url = URL.createObjectURL(dataBlob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `fn_inventory_${
        new Date().toISOString().split("T")[0]
      }.json`;

      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      URL.revokeObjectURL(url);

      console.log("üì§ Exported inventory data");
      return true;
    } catch (err: any) {
      console.error("‚ùå Error exporting inventory:", err);
      setError("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•");
      return false;
    }
  }, [inventory, getInventorySummary]);

  // Clear error
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // Load inventory on mount
  useEffect(() => {
    loadInventory();
  }, [loadInventory]);

  // Auto-save inventory when it changes (debounced)
  useEffect(() => {
    if (!isLoading && inventory.length > 0) {
      const timeoutId = setTimeout(() => {
        saveInventory(inventory);
      }, 1000); // Auto-save after 1 second of no changes

      return () => clearTimeout(timeoutId);
    }
  }, [inventory, isLoading, saveInventory]);

  return {
    // State
    inventory,
    isLoading,
    error,

    // Actions
    addOrUpdateItem,
    updateItemQuantity,
    removeItem,
    clearInventory,
    findItemByBarcode,
    searchItems,
    exportInventory,
    clearError,
    loadInventory,

    // Computed
    summary: getInventorySummary(),
  };
};
